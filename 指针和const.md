# 指针和const

当一个变量使用const修饰后不允许改变他的值，那么使用const修饰指针会怎么样。

**根据const位置的不同有三种效果，原则是修饰谁，谁的内容就不可变，其他的都可变**

# const int*p=&a；
同样const和int可以互换位置，二者是等价的，

当把const放最前面的时候，他修饰的就是*p，那么*p就不可变。*p表示的是指针变量p所指向的内存单元里面的内容，此时这个内容不可变。其他的都可变，如p中存放的是指向的内存单元的地址，这个地址可变，即p的指向可变。但指向谁，谁的内容就不可变。


这种方法常用于定义函数的形参，前面学习的printf和scanf，他们的原型中很多参数都是用const修饰的，这样做的好处是安全！当我们通过参数传递数据时，就把数据暴露了。而大多数时候只是想使用传过来的数据，并不像改变他的值，这样在形参中用const把传过来的数据定义成只读，这也是其最有用的。

**如果不想改变某个参数传递过来的值，那么定义函数时最好用const修饰**

# int*const p=&a；

此时 const 修饰的是 p，所以 p 中存放的内存单元的地址不可变，而内存单元中的内容可变。即 p 的指向不可变，p 所指向的内存单元的内容可变。

# const int*const p=&a；

此时 *p 和 p 都被修饰了，那么 p 中存放的内存单元的地址和内存单元中的内容都不可变。

**综上所述，使用 const 可以保护用指针访问内存时由指针导致的被访问内存空间中数据的误更改。因为指针是直接访问内存的，没有拷贝，而有些时候使用指针访问内存时并不是要改变里面的值，而只是要使用里面的值，所以一旦不小心误操作把里面的数据改了就糟糕了。**

但是这里需要注意的是，上面第 1 种情况中，虽然在 *p 前加上 const 可以禁止指针变量 p 修改变量 a 中的值，但是它只能“禁止指针变量 p 修改”。也就是说，它只能保证在使用指针变量 p 时，p 不能修改 a 中的值。但是我并没有说 const 可以保护 a 禁止一切的修改，其他指向 a 的没有用 const 修饰的指针变量照样可以修改 a 的值，而且变量 a 自己也可以修改自己的值。下面写一个程序看一下：

```
# include <stdio.h>
int main(void)
{   
    int a = 10;
    const int *p = &a;
    int * q = &a;
    *q = 20;
    printf("a = %d\n", a);
    a = 30;
    printf("a = %d\n", a);
    //*p = 30;  //这么写就是错的
    return 0;
}
```

输出结果是：
a = 20
a = 30

可见，只有用 const 修饰过的指针变量 p 不能修改 a 中的内容，而没有用 const 修饰过的指针变量 q 照样可以修改 a 中的内容，而且 a 自己也可以重新给自己赋值。